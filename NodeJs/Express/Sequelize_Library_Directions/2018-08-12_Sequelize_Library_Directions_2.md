# Sequelize 사용법 2

Sequelize의 사용법중 가장 중요한 연관관계 맵핑인 N:M, N:1, 1:1에 대한 부분이다.

우선 연관관계맵핑은 두개의 테이블을 연결을해주는 것이다. 예를 들면 회사테이블과 사원테이블이 있는경우 회사가 1이고 사원이 N인 경우라고 보게 된다. 왜냐하면, 회사의 관점에서는 사원이 여러명이니 N이지만 사원의 관점에서 자신이 소속된 회사는 1개이니 1이라고 보게 된다. 이런식으로 1:1관계, 1:N관계, N:M관계까지 나누어서 보는데, ORM을 사용하지 않고 데이터베이스를 이용하는경우 외래키와 Join을 이용하여 맵핑을 해준다.

<img src="https://user-images.githubusercontent.com/15180507/62872876-51957880-bd59-11e9-935e-0127c1225a26.png" width="200" height="200">

이와 같은 경우를 연관관계 맵핑이라고 하며, Sequelize에서는 **BelongsTo,HasOne,HasMany,BelongsToMany**을 이용하여 연관관계를 맵핑해준다.

연관관계를 맵핑을 해주면, 연결이 되있는 관계를 이용하여, 다른 테이블을 검색하기가 쉬워지는 예를 들면, 사원값을 기준으로 사원이 속해있는 회사의 값을 불러올수 있고, 회사의 값을 기준으로 회사에 속해있는 사원들의 리스트를 구할수도 있을것이다.

이 연관관계는 앞서 sequelize-cli를 통하여 만든 models폴더 내부에있는 모델의 코드를 확인하면 모델명이 있고, `sequelize.defind`함수를 이용하여 테이블을 정의하고 있는부분 그다음에 테이블을 `return`하고 있는 부분으로 이루어져있는데, 우리는 그 사이에 코드를 추가할 것이다

```js
model.associate = models => {
  ...
}
```

## BelongsTo

BelongsTo는 1:1관계에서 사용을 하며, 만약 사원의 입자에서는 1:1관계인 사원-회사를 BelongsTo를 이용하여 연결을 하면, 사원테이블에 회사의 외래키가 생성이 될 것이다.

```js
사원.belongsTo(models.회사, { foreignKey: "회사Id" });
```

## HasOne

HasOne도 1:1관계에서 사용을 하며, BelongsTo와 같은 결과를 내려면 다음과 같이 생성하면 된다.

```js
회사.hasOne(models.사원, { foreignKey: "회사Id" });
```

---

쉽게 설명을 하면, hasOne은 연결을 하는 상대 테이블에 외래키를 생성하고, belongsTo연결을 하는 상대의 외래키를 자신의 테이블에 생성을 하는 차이점이 있다. 이를 이용해서 1:N관계에서 사용이 가능하다.

## HasMany

HasMany는 1:N관계에서 사용하며, 회사가 1이고 사원이 N이므로, 다음과 같이 사용이 가능하다.

```js
회사.hasMany(models.사원, { foreignKey: "회사Id" });
```

hasMany를 이용하면, 회사에서는 사원의 목록을 검색이 가능해진다. 물론 사원이 회사를 확인하려면 1:1연결을 해주면 된다.

## belongsToMany

N:M관계는 관계를 저장할 테이블을 따로 추가를 해주며, 테이블명을 따로 추가를 해줄수 있다. 우선 예제로 사원과 사원과의 관계인 동료라는 관계를 추가를 해주어 N:M관계를 만들어 보겠다.

```js
사원.belongsToMany(사원, {
  as: "동료목록",
  through: "동료",
  foreignKey: "사원Id",
  otherKey: "동료Id"
});
```

위와 같은 식으로 작성을 하면, 동료라는 테이블이 생길것이며, 인자값으로는 사원Id, 동료Id이 생길것이다.

---

이를 이용하여 관계맵핑을 완료하면 sequelize의 model정의가 완전히 끝난것이며, model관련해서 추가적으로 할만한것은 hook정도가 있으니 추가적으로 공부를 하고 싶으면 [이곳](https://sequelize.org/master/manual/hooks.html)에서 확인을 하고 공부를 하면 될것같다.
